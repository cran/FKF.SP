<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Fast Kalman Filtering using Sequential Processing</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Fast Kalman Filtering using Sequential Processing</h1>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This document provides worked examples of Kalman filtering using the ‘fkf.SP’ function of the ‘FKF.SP’ package. The ‘fkf’ function of the package ‘FKF’ (Fast Kalman Filter) is a well-established function call of the Kalman filter algorithm that is designed to maximize computational efficiency of the filtering process. The ‘fkf.SP’ function builds from the ‘fkf’ function by taking the additional assumption that the variance of disturbances of the measurement equation are independent. This allows filtering to be performed through a sequential processing method (i.e. a univariate treatment of the multivariate process) - increasing computational efficiency in the general case. This vignette provides four worked examples, comparing the computational efficiencies of the ‘fkf’ and ‘fkf.SP’ functions for maximum likelihood estimation (MLE). The first three examples were first presented within the associated vignette of the ‘FKF’ package, with the fourth being unique to the vignette. As well as the increase in processing time generated by the ‘fkf.SP’ function, this vignette further presents and explains the difference in log-likelihood values returned by the ‘fkf’ and ‘fkf.SP’ functions when there are missing observations (i.e. NA’s are present within argument ‘yt’).</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">##The packages &#39;FKF&#39;, &#39;stats&#39; and &#39;NFCP&#39; are required for this Vignette:</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">library</span>(FKF.SP)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">library</span>(FKF)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">library</span>(stats)</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">library</span>(NFCP)</span></code></pre></div>
</div>
<div id="example-1---arma21-model-estimation." class="section level2">
<h2>Example 1 - ARMA(2,1) model estimation.</h2>
<p>Autoregression moving average models can be estimated through Kalman filtering. See also help(makeARIMA) and help(KalmanRun).</p>
<p>Step 1 - Sample from an ARMA(2, 1) process through the ‘stats’ package to generate observations:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="co"># Set constants:</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">## Length of series</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>n &lt;-<span class="st"> </span><span class="dv">10000</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co">## AR parameters</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>AR &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">ar1 =</span> <span class="fl">0.6</span>, <span class="dt">ar2 =</span> <span class="fl">0.2</span>, <span class="dt">ma1 =</span> <span class="fl">-0.2</span>, <span class="dt">sigma =</span> <span class="kw">sqrt</span>(<span class="fl">0.2</span>))</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co"># Generate observations:</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb2-10"><a href="#cb2-10"></a>a &lt;-<span class="st"> </span>stats<span class="op">::</span><span class="kw">arima.sim</span>(<span class="dt">model =</span> <span class="kw">list</span>(<span class="dt">ar =</span> AR[<span class="kw">c</span>(<span class="st">&quot;ar1&quot;</span>, <span class="st">&quot;ar2&quot;</span>)], <span class="dt">ma =</span> AR[<span class="st">&quot;ma1&quot;</span>]), <span class="dt">n =</span> n,</span>
<span id="cb2-11"><a href="#cb2-11"></a>            <span class="dt">innov =</span> <span class="kw">rnorm</span>(n) <span class="op">*</span><span class="st"> </span>AR[<span class="st">&quot;sigma&quot;</span>])</span></code></pre></div>
<p>Step 2 - Create a state space representation of the four ARMA parameters:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>arma21ss &lt;-<span class="st"> </span><span class="cf">function</span>(ar1, ar2, ma1, sigma) {</span>
<span id="cb3-2"><a href="#cb3-2"></a>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(ar1, ar2, <span class="dv">1</span>, <span class="dv">0</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>Zt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb3-4"><a href="#cb3-4"></a>ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)</span>
<span id="cb3-5"><a href="#cb3-5"></a>dt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> <span class="dv">2</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a>GGt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)</span>
<span id="cb3-7"><a href="#cb3-7"></a>H &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, ma1), <span class="dt">nrow =</span> <span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>sigma</span>
<span id="cb3-8"><a href="#cb3-8"></a>HHt &lt;-<span class="st"> </span>H <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(H)</span>
<span id="cb3-9"><a href="#cb3-9"></a>a0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">## Diffuse assumption</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="fl">1e6</span>, <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">ct =</span> ct, <span class="dt">dt =</span> dt, <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt, <span class="dt">GGt =</span> GGt,</span>
<span id="cb3-13"><a href="#cb3-13"></a>            <span class="dt">HHt =</span> HHt))}</span></code></pre></div>
<p>Parameter estimation is performed through MLE, which involves optimizing the log-likelihood returned by the Kalman filter through the ‘optim’ function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># The objective function passed to &#39;optim&#39;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>objective &lt;-<span class="st"> </span><span class="cf">function</span>(theta, yt, SP) {</span>
<span id="cb4-3"><a href="#cb4-3"></a>param &lt;-<span class="st"> </span><span class="kw">arma21ss</span>(theta[<span class="st">&quot;ar1&quot;</span>], theta[<span class="st">&quot;ar2&quot;</span>], theta[<span class="st">&quot;ma1&quot;</span>], theta[<span class="st">&quot;sigma&quot;</span>])</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co"># Kalman filtering through the &#39;fkf.SP&#39; function:</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="cf">if</span>(SP){</span>
<span id="cb4-6"><a href="#cb4-6"></a> ans &lt;-<span class="st"> </span><span class="op">-</span><span class="st"> </span><span class="kw">fkf.SP</span>(<span class="dt">a0 =</span> param<span class="op">$</span>a0, <span class="dt">P0 =</span> param<span class="op">$</span>P0, <span class="dt">dt =</span> param<span class="op">$</span>dt, <span class="dt">ct =</span> param<span class="op">$</span>ct, </span>
<span id="cb4-7"><a href="#cb4-7"></a>               <span class="dt">Tt =</span> param<span class="op">$</span>Tt, <span class="dt">Zt =</span> param<span class="op">$</span>Zt, <span class="dt">HHt =</span> param<span class="op">$</span>HHt, <span class="dt">GGt =</span> param<span class="op">$</span>GGt, </span>
<span id="cb4-8"><a href="#cb4-8"></a>               <span class="dt">yt =</span> yt)</span>
<span id="cb4-9"><a href="#cb4-9"></a> }</span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="co"># Kalman filtering through the &#39;fkf&#39; function:</span></span>
<span id="cb4-11"><a href="#cb4-11"></a> <span class="cf">else</span>{</span>
<span id="cb4-12"><a href="#cb4-12"></a> ans &lt;-<span class="st"> </span><span class="op">-</span><span class="st"> </span><span class="kw">fkf</span>(<span class="dt">a0 =</span> param<span class="op">$</span>a0, <span class="dt">P0 =</span> param<span class="op">$</span>P0, <span class="dt">dt =</span> param<span class="op">$</span>dt, <span class="dt">ct =</span> param<span class="op">$</span>ct, <span class="dt">Tt =</span> param<span class="op">$</span>Tt,</span>
<span id="cb4-13"><a href="#cb4-13"></a>            <span class="dt">Zt =</span> param<span class="op">$</span>Zt, <span class="dt">HHt =</span> param<span class="op">$</span>HHt, <span class="dt">GGt =</span> param<span class="op">$</span>GGt, <span class="dt">yt =</span> yt)<span class="op">$</span>logLik</span>
<span id="cb4-14"><a href="#cb4-14"></a>   </span>
<span id="cb4-15"><a href="#cb4-15"></a> }</span>
<span id="cb4-16"><a href="#cb4-16"></a> <span class="kw">return</span>(ans)</span>
<span id="cb4-17"><a href="#cb4-17"></a>}</span>
<span id="cb4-18"><a href="#cb4-18"></a><span class="co">##Optim minimizes functions by default, so the negative is returned</span></span></code></pre></div>
<p>Step 3 - Estimate parameters through MLE:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">#This test estimates parameters through &#39;optim&#39;.</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">#Please run the complete chunk for a fair comparison:</span></span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">#Initial values:</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>theta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">ar =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>), <span class="dt">ma1 =</span> <span class="dv">0</span>, <span class="dt">sigma =</span> <span class="dv">1</span>)</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">###MLE through the &#39;fkf&#39; function:</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>start &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb5-10"><a href="#cb5-10"></a>FKF_estimation &lt;-<span class="st"> </span><span class="kw">optim</span>(theta, objective, <span class="dt">yt =</span> <span class="kw">rbind</span>(a), <span class="dt">hessian =</span> <span class="ot">TRUE</span>, <span class="dt">SP =</span> F)</span>
<span id="cb5-11"><a href="#cb5-11"></a>FKF_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb5-12"><a href="#cb5-12"></a></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="co">###MLE through the &#39;fkf.SP&#39; function:</span></span>
<span id="cb5-14"><a href="#cb5-14"></a>start &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb5-16"><a href="#cb5-16"></a>FKF.SP_estimation &lt;-<span class="st"> </span><span class="kw">optim</span>(theta, objective, <span class="dt">yt =</span> <span class="kw">rbind</span>(a), <span class="dt">hessian =</span> <span class="ot">TRUE</span>, <span class="dt">SP =</span> T)</span>
<span id="cb5-17"><a href="#cb5-17"></a>FKF.SP_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span></code></pre></div>
<p>The MLE process applying both functions has returned identical estimated parameters:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">print</span>(<span class="kw">rbind</span>(<span class="dt">FKF.SP =</span> FKF.SP_estimation<span class="op">$</span>par, <span class="dt">FKF =</span> FKF_estimation<span class="op">$</span>par))</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co">#&gt;              ar1       ar2        ma1     sigma</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">#&gt; FKF.SP 0.5534615 0.2276404 -0.1413417 0.4525427</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">#&gt; FKF    0.5534615 0.2276404 -0.1413417 0.4525427</span></span></code></pre></div>
<p>As well as an identical call count number for both functions:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> FKF.SP_estimation<span class="op">$</span>counts[<span class="dv">1</span>], <span class="dt">FKF =</span> FKF_estimation<span class="op">$</span>counts[<span class="dv">1</span>]))</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">#&gt; FKF.SP.function    FKF.function </span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co">#&gt;             265             265</span></span></code></pre></div>
<p>Utilizing Sequential Processing however, we’ve decreased processing time:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> FKF.SP_runtime, <span class="dt">FKF =</span> FKF_runtime))</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">#&gt; Time differences in secs</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">#&gt;   FKF.SP      FKF </span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">#&gt; 1.362323 2.251976</span></span></code></pre></div>
<p>The vignette of ‘FKF’ shows how to filter the series with estimated parameter values and develop some plots for analysis purposes. ‘fkf.SP’ is only appropriate for efficient parameter estimation, rather than the filtering under estimated parameters.</p>
</div>
<div id="example-2---local-level-model-for-the-niles-annual-flow" class="section level2">
<h2>Example 2 - Local level model for the Nile’s annual flow:</h2>
<p>This example presents differences in the computational time of the ‘fkf.SP’ and ‘fkf’ functions to the Nile dataset. It also shows the difference in log-likelihood values returned by the two functions that occurs when NAs are within observations.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">## Transition equation:</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co">## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co">## Measurement equation:</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co">## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)</span></span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co">##Complete Nile Data - no NA&#39;s</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>y_complete &lt;-<span class="st"> </span>y_incomplete &lt;-<span class="st"> </span>Nile</span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="co">##Incomplete Nile Data - two NA&#39;s are present:</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>y_incomplete[<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">10</span>)] &lt;-<span class="st"> </span><span class="ot">NA</span></span>
<span id="cb9-10"><a href="#cb9-10"></a></span>
<span id="cb9-11"><a href="#cb9-11"></a></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="co">## Set constant parameters:</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>dt &lt;-<span class="st"> </span>ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)</span>
<span id="cb9-14"><a href="#cb9-14"></a>Zt &lt;-<span class="st"> </span>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)</span>
<span id="cb9-15"><a href="#cb9-15"></a>a0 &lt;-<span class="st"> </span>y_incomplete[<span class="dv">1</span>]   <span class="co"># Estimation of the first year flow</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">100</span>)     <span class="co"># Variance of &#39;a0&#39;</span></span>
<span id="cb9-17"><a href="#cb9-17"></a></span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="co">## Parameter estimation - maximum likelihood estimation:</span></span>
<span id="cb9-19"><a href="#cb9-19"></a>Nile_MLE &lt;-<span class="st"> </span><span class="cf">function</span>(yt, SP){</span>
<span id="cb9-20"><a href="#cb9-20"></a><span class="co">##Unknown parameters initial estimates:</span></span>
<span id="cb9-21"><a href="#cb9-21"></a>GGt &lt;-<span class="st"> </span>HHt &lt;-<span class="st"> </span><span class="kw">var</span>(yt, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span></span>
<span id="cb9-22"><a href="#cb9-22"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb9-23"><a href="#cb9-23"></a><span class="co"># Kalman filtering through the &#39;fkf.SP&#39; function:</span></span>
<span id="cb9-24"><a href="#cb9-24"></a><span class="cf">if</span>(SP){</span>
<span id="cb9-25"><a href="#cb9-25"></a>  <span class="kw">return</span>(<span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt),</span>
<span id="cb9-26"><a href="#cb9-26"></a>        <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)</span>
<span id="cb9-27"><a href="#cb9-27"></a>             <span class="op">-</span><span class="kw">fkf.SP</span>(<span class="dt">HHt =</span> <span class="kw">matrix</span>(par[<span class="dv">1</span>]), <span class="dt">GGt =</span> <span class="kw">matrix</span>(par[<span class="dv">2</span>]), ...),</span>
<span id="cb9-28"><a href="#cb9-28"></a>             <span class="dt">yt =</span> <span class="kw">rbind</span>(yt), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,</span>
<span id="cb9-29"><a href="#cb9-29"></a>             <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt))</span>
<span id="cb9-30"><a href="#cb9-30"></a>} <span class="cf">else</span> {</span>
<span id="cb9-31"><a href="#cb9-31"></a><span class="co"># Kalman filtering through the &#39;fkf&#39; function:</span></span>
<span id="cb9-32"><a href="#cb9-32"></a>  <span class="kw">return</span>(<span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt),</span>
<span id="cb9-33"><a href="#cb9-33"></a>        <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)</span>
<span id="cb9-34"><a href="#cb9-34"></a>             <span class="op">-</span><span class="kw">fkf</span>(<span class="dt">HHt =</span> <span class="kw">matrix</span>(par[<span class="dv">1</span>]), <span class="dt">GGt =</span> <span class="kw">matrix</span>(par[<span class="dv">2</span>]), ...)<span class="op">$</span>logLik,</span>
<span id="cb9-35"><a href="#cb9-35"></a>             <span class="dt">yt =</span> <span class="kw">rbind</span>(yt), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,</span>
<span id="cb9-36"><a href="#cb9-36"></a>             <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt))</span>
<span id="cb9-37"><a href="#cb9-37"></a>}}</span></code></pre></div>
<p>Performing parameter estimation using complete data, the fkf and fkf.SP functions return identical results:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>fkf.SP_MLE_complete &lt;-<span class="st"> </span><span class="kw">Nile_MLE</span>(y_complete, <span class="dt">SP =</span> T)</span>
<span id="cb10-2"><a href="#cb10-2"></a>fkf_MLE_complete &lt;-<span class="st"> </span><span class="kw">Nile_MLE</span>(y_complete, <span class="dt">SP =</span> F)</span></code></pre></div>
<p>fkf.SP:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">print</span>(fkf.SP_MLE_complete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="co">#&gt; $par</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="co">#&gt;       HHt       GGt </span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="co">#&gt;  1300.777 15247.773 </span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="co">#&gt; </span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="co">#&gt; $value</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="co">#&gt; [1] 637.626</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="co">#&gt; </span></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="co">#&gt; $counts</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="co">#&gt;       57       NA</span></span></code></pre></div>
<p>fkf:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">print</span>(fkf_MLE_complete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="co">#&gt; $par</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co">#&gt;       HHt       GGt </span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="co">#&gt;  1300.777 15247.773 </span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="co">#&gt; </span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="co">#&gt; $value</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="co">#&gt; [1] 637.626</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="co">#&gt; </span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="co">#&gt; $counts</span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="co">#&gt;       57       NA</span></span></code></pre></div>
<p>Performing parameter estimation using incomplete data returns identical estimated parameters, but different log-likelihood values:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a>fkf.SP_MLE_incomplete &lt;-<span class="st"> </span><span class="kw">Nile_MLE</span>(y_incomplete, <span class="dt">SP =</span> T)</span>
<span id="cb13-2"><a href="#cb13-2"></a>fkf_MLE_incomplete &lt;-<span class="st"> </span><span class="kw">Nile_MLE</span>(y_incomplete, <span class="dt">SP =</span> F)</span></code></pre></div>
<p>‘fkf.SP’:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">print</span>(fkf.SP_MLE_incomplete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="co">#&gt; $par</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co">#&gt;       HHt       GGt </span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="co">#&gt;  1385.066 15124.131 </span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="co">#&gt; </span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="co">#&gt; $value</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="co">#&gt; [1] 625.1676</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="co">#&gt; </span></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="co">#&gt; $counts</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="co">#&gt;       53       NA</span></span></code></pre></div>
<p>‘fkf’:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">print</span>(fkf_MLE_incomplete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="co">#&gt; $par</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co">#&gt;       HHt       GGt </span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="co">#&gt;  1385.066 15124.131 </span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="co">#&gt; </span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="co">#&gt; $value</span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="co">#&gt; [1] 627.0055</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="co">#&gt; </span></span>
<span id="cb15-9"><a href="#cb15-9"></a><span class="co">#&gt; $counts</span></span>
<span id="cb15-10"><a href="#cb15-10"></a><span class="co">#&gt; function gradient </span></span>
<span id="cb15-11"><a href="#cb15-11"></a><span class="co">#&gt;       53       NA</span></span></code></pre></div>
<p>The difference in log-likelihood values is equal to 1.8378771. This difference is equal to:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">#Number of NA values:</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>NA_values &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">which</span>(<span class="kw">is.na</span>(y_incomplete)))</span>
<span id="cb16-3"><a href="#cb16-3"></a></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">print</span>( <span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>NA_values <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(<span class="dv">2</span> <span class="op">*</span><span class="st"> </span>pi))</span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="co">#&gt; [1] 1.837877</span></span></code></pre></div>
<p>The log-likelihood score for the Kalman filter is given by:</p>
<p><span class="math display">\[ - \frac{1}{2}(n \times d \times log(2\pi)) - \frac{1}{2}\sum_{t=1}^{n}(log|F_t| + v&#39;F^{-1}v)\]</span> where <span class="math inline">\(n\)</span> is the number of discrete time-steps (i.e. the number of columns of object ‘yt’) and <span class="math inline">\(d\)</span> is the number of observations at each time point (i.e. the number of rows of object ‘yt’). <span class="math inline">\(v\)</span> and <span class="math inline">\(F_t\)</span> are the measurement error and function of the covariance matrix at time <span class="math inline">\(t\)</span> respectively. The ‘fkf’ function instantiates its log-likelihood score by calculating <span class="math inline">\(- 0.5 \times n \times d \times log(2\pi)\)</span>. Under the scenario where there are missing observations, however, <span class="math inline">\(d\)</span> would instead become <span class="math inline">\(d_t\)</span> where <span class="math inline">\(d_t \leq d \forall t\)</span>. The instantiated log-likelihood term would instead be <span class="math inline">\(- 0.5 ((n \times d)-2) \times log(2\pi)\)</span>, explaining this difference in log-likelihood scores. The ‘fkf’ function therefore instantiates the log-likelihood score of two observations that are not actually observed.</p>
<div id="speed-comparison---nile-data-10000-iterations" class="section level3">
<h3>Speed Comparison - Nile Data (10,000 iterations):</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">#This test uses estimated parameters of complete data. </span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="co">#Please run the complete chunk for a fair comparison:</span></span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="co">#&#39;fkf&#39; </span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb17-6"><a href="#cb17-6"></a>start &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb17-7"><a href="#cb17-7"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e4</span>) <span class="kw">fkf</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">matrix</span>(fkf_MLE_complete<span class="op">$</span>par[<span class="dv">1</span>]),</span>
<span id="cb17-8"><a href="#cb17-8"></a>                    <span class="dt">GGt =</span> <span class="kw">matrix</span>(fkf_MLE_complete<span class="op">$</span>par[<span class="dv">2</span>]), <span class="dt">yt =</span> <span class="kw">rbind</span>(y_complete))</span>
<span id="cb17-9"><a href="#cb17-9"></a>FKF_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb17-10"><a href="#cb17-10"></a></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="co">#&#39;fkf.SP&#39;</span></span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb17-13"><a href="#cb17-13"></a>start =<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e4</span>) <span class="kw">fkf.SP</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">matrix</span>(fkf.SP_MLE_complete<span class="op">$</span>par[<span class="dv">1</span>]),</span>
<span id="cb17-15"><a href="#cb17-15"></a>                       <span class="dt">GGt =</span> <span class="kw">matrix</span>(fkf.SP_MLE_complete<span class="op">$</span>par[<span class="dv">2</span>]), <span class="dt">yt =</span> <span class="kw">rbind</span>(y_complete))</span>
<span id="cb17-16"><a href="#cb17-16"></a>fkf.SP_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb17-17"><a href="#cb17-17"></a></span>
<span id="cb17-18"><a href="#cb17-18"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> fkf.SP_runtime, <span class="dt">FKF =</span> FKF_runtime))</span>
<span id="cb17-19"><a href="#cb17-19"></a><span class="co">#&gt; Time differences in secs</span></span>
<span id="cb17-20"><a href="#cb17-20"></a><span class="co">#&gt;   FKF.SP      FKF </span></span>
<span id="cb17-21"><a href="#cb17-21"></a><span class="co">#&gt; 1.096068 1.637622</span></span></code></pre></div>
<p>Utilizing Sequential Processing has decreased processing time.</p>
</div>
</div>
<div id="example-3---tree-ring-data" class="section level2">
<h2>Example 3 - Tree Ring Data:</h2>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="co">#This test estimates parameters 10 times through &#39;optim&#39;.</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="co">#Please run the complete chunk for a fair comparison:</span></span>
<span id="cb18-3"><a href="#cb18-3"></a></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="co">## Transition equation:</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="co">## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="co">## Measurement equation:</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)</span></span>
<span id="cb18-8"><a href="#cb18-8"></a></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="co">## tree-ring widths in dimensionless units</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>y &lt;-<span class="st"> </span>treering</span>
<span id="cb18-11"><a href="#cb18-11"></a></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="co">## Set constant parameters:</span></span>
<span id="cb18-13"><a href="#cb18-13"></a>dt &lt;-<span class="st"> </span>ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)</span>
<span id="cb18-14"><a href="#cb18-14"></a>Zt &lt;-<span class="st"> </span>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)</span>
<span id="cb18-15"><a href="#cb18-15"></a>a0 &lt;-<span class="st"> </span>y[<span class="dv">1</span>]            <span class="co"># Estimation of the first width</span></span>
<span id="cb18-16"><a href="#cb18-16"></a>P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">100</span>)     <span class="co"># Variance of &#39;a0&#39;</span></span>
<span id="cb18-17"><a href="#cb18-17"></a></span>
<span id="cb18-18"><a href="#cb18-18"></a><span class="co">##Time comparison - Estimate parameters 10 times:</span></span>
<span id="cb18-19"><a href="#cb18-19"></a></span>
<span id="cb18-20"><a href="#cb18-20"></a><span class="co">###MLE through the &#39;fkf&#39; function:</span></span>
<span id="cb18-21"><a href="#cb18-21"></a>start =<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb18-22"><a href="#cb18-22"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb18-23"><a href="#cb18-23"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)  fit.fkf &lt;-<span class="st"> </span><span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span>,</span>
<span id="cb18-24"><a href="#cb18-24"></a>                     <span class="dt">GGt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span>),</span>
<span id="cb18-25"><a href="#cb18-25"></a>                   <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)</span>
<span id="cb18-26"><a href="#cb18-26"></a>                     <span class="op">-</span><span class="kw">fkf</span>(<span class="dt">HHt =</span> <span class="kw">array</span>(par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), <span class="dt">GGt =</span> <span class="kw">array</span>(par[<span class="dv">2</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), ...)<span class="op">$</span>logLik,</span>
<span id="cb18-27"><a href="#cb18-27"></a>                   <span class="dt">yt =</span> <span class="kw">rbind</span>(y), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,</span>
<span id="cb18-28"><a href="#cb18-28"></a>                   <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt)</span>
<span id="cb18-29"><a href="#cb18-29"></a></span>
<span id="cb18-30"><a href="#cb18-30"></a>run.time_FKF =<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb18-31"><a href="#cb18-31"></a></span>
<span id="cb18-32"><a href="#cb18-32"></a><span class="co">###MLE through the &#39;fkf.SP&#39; function:</span></span>
<span id="cb18-33"><a href="#cb18-33"></a>start =<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb18-34"><a href="#cb18-34"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb18-35"><a href="#cb18-35"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)  fit.fkf.SP &lt;-<span class="st"> </span><span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span>,</span>
<span id="cb18-36"><a href="#cb18-36"></a>                        <span class="dt">GGt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span><span class="fl">.5</span>),</span>
<span id="cb18-37"><a href="#cb18-37"></a>                      <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)</span>
<span id="cb18-38"><a href="#cb18-38"></a>                        <span class="op">-</span><span class="kw">fkf.SP</span>(<span class="dt">HHt =</span> <span class="kw">array</span>(par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), <span class="dt">GGt =</span> <span class="kw">matrix</span>(par[<span class="dv">2</span>]), ...),</span>
<span id="cb18-39"><a href="#cb18-39"></a>                      <span class="dt">yt =</span> <span class="kw">rbind</span>(y), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,</span>
<span id="cb18-40"><a href="#cb18-40"></a>                      <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt)</span>
<span id="cb18-41"><a href="#cb18-41"></a>run.time_FKF.SP =<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb18-42"><a href="#cb18-42"></a></span>
<span id="cb18-43"><a href="#cb18-43"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">fkf.SP =</span> run.time_FKF.SP, <span class="dt">fkf =</span> run.time_FKF))</span>
<span id="cb18-44"><a href="#cb18-44"></a><span class="co">#&gt; Time differences in secs</span></span>
<span id="cb18-45"><a href="#cb18-45"></a><span class="co">#&gt;   fkf.SP      fkf </span></span>
<span id="cb18-46"><a href="#cb18-46"></a><span class="co">#&gt; 2.091378 3.261278</span></span>
<span id="cb18-47"><a href="#cb18-47"></a></span>
<span id="cb18-48"><a href="#cb18-48"></a><span class="co">## Filter tree ring data with estimated parameters using &#39;fkf&#39;:</span></span>
<span id="cb18-49"><a href="#cb18-49"></a>fkf.obj &lt;-<span class="st"> </span><span class="kw">fkf</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">array</span>(fit.fkf<span class="op">$</span>par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)),</span>
<span id="cb18-50"><a href="#cb18-50"></a>               <span class="dt">GGt =</span> <span class="kw">array</span>(fit.fkf<span class="op">$</span>par[<span class="dv">2</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), <span class="dt">yt =</span> <span class="kw">rbind</span>(y))</span></code></pre></div>
<p>Utilizing Sequential Processing has decreased processing time.</p>
</div>
<div id="example-4---fitting-a-geometric-brownian-motion-gbm-to-term-structure-data" class="section level2">
<h2>Example 4 - Fitting a Geometric Brownian Motion (GBM) to Term Structure Data:</h2>
<p>The Kalman filter can be used to fit stochastic models to time-series data of quoted prices of futures contracts of commodities. The following example estimates the parameters of a random walk (i.e. Geometric Brownian Motion) model for crude oil through MLE. Quoted futures contracts are available in the ‘NFCP’ package. See the ‘NFCP’ documentation for more details on fitting commodity pricing models to term structure data.</p>
<p>Step 1 - develop the objective function:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a></span>
<span id="cb19-2"><a href="#cb19-2"></a>yt =<span class="st"> </span><span class="kw">t</span>(<span class="kw">log</span>(NFCP<span class="op">::</span>SS.Oil<span class="op">$</span>Contracts)) <span class="co"># quoted log futures prices</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>delta.t &lt;-<span class="st"> </span>NFCP<span class="op">::</span>SS.Oil<span class="op">$</span>dt <span class="co"># Discrete time step</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="co">##time to maturity of quoted futures contracts:</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>TTM &lt;-<span class="st"> </span><span class="kw">t</span>(NFCP<span class="op">::</span>SS.Oil<span class="op">$</span>Contract.Maturities)</span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a>a0 &lt;-<span class="st"> </span>yt[<span class="dv">1</span>,<span class="dv">1</span>]     <span class="co"># initial estimate</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">100</span>) <span class="co"># Variance of &#39;a0&#39;</span></span>
<span id="cb19-9"><a href="#cb19-9"></a></span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="co">## GBM Function</span></span>
<span id="cb19-11"><a href="#cb19-11"></a>gbm.mle &lt;-<span class="st"> </span><span class="cf">function</span>(theta, SP){</span>
<span id="cb19-12"><a href="#cb19-12"></a></span>
<span id="cb19-13"><a href="#cb19-13"></a>ct &lt;-<span class="st"> </span>theta[<span class="st">&quot;alpha.rn&quot;</span>] <span class="op">*</span><span class="st"> </span>TTM</span>
<span id="cb19-14"><a href="#cb19-14"></a>dt &lt;-<span class="st"> </span>(theta[<span class="st">&quot;alpha&quot;</span>] <span class="op">-</span><span class="st"> </span><span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>theta[<span class="st">&quot;sigma&quot;</span>]<span class="op">^</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>delta.t</span>
<span id="cb19-15"><a href="#cb19-15"></a>Zt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(yt))</span>
<span id="cb19-16"><a href="#cb19-16"></a>HHt &lt;-<span class="st"> </span><span class="kw">matrix</span>(theta[<span class="st">&quot;sigma&quot;</span>]<span class="op">^</span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta.t)</span>
<span id="cb19-17"><a href="#cb19-17"></a>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)</span>
<span id="cb19-18"><a href="#cb19-18"></a></span>
<span id="cb19-19"><a href="#cb19-19"></a><span class="co">##&#39;fkf.SP&#39; requires a vector of the diagonal elements of the variances of the measurement error </span></span>
<span id="cb19-20"><a href="#cb19-20"></a><span class="cf">if</span>(SP){</span>
<span id="cb19-21"><a href="#cb19-21"></a>GGt =<span class="st"> </span><span class="kw">rep</span>(theta[<span class="st">&quot;sigma.epsilon&quot;</span>]<span class="op">^</span><span class="dv">2</span>, <span class="kw">nrow</span>(yt))</span>
<span id="cb19-22"><a href="#cb19-22"></a>} <span class="cf">else</span> {</span>
<span id="cb19-23"><a href="#cb19-23"></a><span class="co">##&#39;fkf&#39; instead requires a matrix of the elements of the variances of the measurement error </span></span>
<span id="cb19-24"><a href="#cb19-24"></a>GGt =<span class="st"> </span><span class="kw">diag</span>(theta[<span class="st">&quot;sigma.epsilon&quot;</span>]<span class="op">^</span><span class="dv">2</span>, <span class="kw">nrow</span>(yt))</span>
<span id="cb19-25"><a href="#cb19-25"></a>}</span>
<span id="cb19-26"><a href="#cb19-26"></a></span>
<span id="cb19-27"><a href="#cb19-27"></a>logLik =<span class="st"> </span><span class="kw">ifelse</span>(SP,</span>
<span id="cb19-28"><a href="#cb19-28"></a>                <span class="op">-</span><span class="st"> </span><span class="kw">fkf.SP</span>(<span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct, <span class="dt">Tt =</span> Tt, <span class="dt">Zt =</span> Zt, <span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt, <span class="dt">yt =</span> yt),</span>
<span id="cb19-29"><a href="#cb19-29"></a>                <span class="op">-</span><span class="st"> </span><span class="kw">fkf</span>(<span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct, <span class="dt">Tt =</span> Tt, <span class="dt">Zt =</span> Zt, <span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt, <span class="dt">yt =</span> yt)<span class="op">$</span>logLik</span>
<span id="cb19-30"><a href="#cb19-30"></a>                )</span>
<span id="cb19-31"><a href="#cb19-31"></a><span class="kw">return</span>(logLik)</span>
<span id="cb19-32"><a href="#cb19-32"></a>}</span></code></pre></div>
<p>Step 3 - Perform MLE:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a><span class="co">#This test estimates parameters through &#39;optim&#39;.</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="co">#Please run the complete chunk for a fair comparison:</span></span>
<span id="cb20-3"><a href="#cb20-3"></a></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co">#Initial estimates</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>gbm.par &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">alpha =</span> <span class="dv">0</span>, <span class="dt">alpha.rn =</span> <span class="fl">0.01</span>, <span class="dt">sigma =</span> <span class="fl">0.1</span>, <span class="dt">sigma.epsilon =</span> <span class="fl">0.05</span>)</span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="co">###MLE through the &#39;fkf.SP&#39; function:</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-9"><a href="#cb20-9"></a>start =<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb20-10"><a href="#cb20-10"></a>fkf.SP.gbm =<span class="st"> </span><span class="kw">optim</span>(<span class="dt">par =</span> gbm.par, <span class="dt">fn =</span> gbm.mle, <span class="dt">SP =</span> T)</span>
<span id="cb20-11"><a href="#cb20-11"></a>fkf.SP_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span>
<span id="cb20-12"><a href="#cb20-12"></a></span>
<span id="cb20-13"><a href="#cb20-13"></a><span class="co">###MLE through the &#39;fkf&#39; function:</span></span>
<span id="cb20-14"><a href="#cb20-14"></a><span class="kw">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb20-15"><a href="#cb20-15"></a>start =<span class="st"> </span><span class="kw">Sys.time</span>()</span>
<span id="cb20-16"><a href="#cb20-16"></a>fkf.gbm =<span class="st"> </span><span class="kw">optim</span>(<span class="dt">par =</span> gbm.par, <span class="dt">fn =</span> gbm.mle, <span class="dt">SP =</span> F)</span>
<span id="cb20-17"><a href="#cb20-17"></a>fkf_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</span></code></pre></div>
<p>The presence of a large number of NA’s in the observation matrix (i.e. object ‘yt’) has resulted in significantly different MLE scores of both functions (see Example 3 for more details):</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">print</span>(<span class="kw">rbind</span>(<span class="dt">FKF.SP =</span> <span class="op">-</span><span class="st"> </span>fkf.SP.gbm<span class="op">$</span>value, <span class="dt">FKF =</span> <span class="op">-</span><span class="st"> </span>fkf.gbm<span class="op">$</span>value))</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="co">#&gt;             [,1]</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="co">#&gt; FKF.SP 10221.345</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="co">#&gt; FKF    -4778.489</span></span></code></pre></div>
<p>Regardless, The MLE process applying both functions has returned nearly identical estimated parameters:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">print</span>(<span class="kw">rbind</span>(<span class="dt">FKF.SP =</span> fkf.SP.gbm<span class="op">$</span>par, <span class="dt">FKF =</span> fkf.gbm<span class="op">$</span>par))</span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="co">#&gt;              alpha    alpha.rn     sigma sigma.epsilon</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="co">#&gt; FKF.SP -0.02283278 0.001236720 0.2070780    0.03721549</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="co">#&gt; FKF    -0.02277886 0.001234892 0.2071917    0.03721757</span></span></code></pre></div>
<p>As well as a nearly identical call count number for both functions:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> fkf.SP.gbm<span class="op">$</span>counts[<span class="dv">1</span>], <span class="dt">FKF =</span> fkf.gbm<span class="op">$</span>counts[<span class="dv">1</span>]))</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="co">#&gt; FKF.SP.function    FKF.function </span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="co">#&gt;             145             153</span></span></code></pre></div>
<p>A sequential processing approach, however, has significantly decreased processing time:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> fkf.SP_runtime, <span class="dt">FKF =</span> fkf_runtime))</span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="co">#&gt; Time differences in secs</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="co">#&gt;   FKF.SP      FKF </span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="co">#&gt; 0.273272 1.576784</span></span></code></pre></div>
<p>Sequential processing is a significantly faster Kalman filtering approach for this particular example due to the large number of observations at each time point, the assumption that the variance of the disturbances are independent, the large number of NA’s that are observed as contracts expired or are made available and the dimensionality of argument ‘GGt’ being significantly reduced.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Fast Kalman Filtering using Sequential Processing</title>


<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>



<style type="text/css">
  code {
    white-space: pre;
  }
  .sourceCode {
    overflow: visible;
  }
</style>
<style type="text/css" data-origin="pandoc">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />




</head>

<body>




<h1 class="title toc-ignore">Fast Kalman Filtering using Sequential Processing</h1>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This document provides worked examples of Kalman filtering and smoothing using the 'fkf.SP' and 'fks.SP' functions of the 'FKF.SP' package. Sequential processing of the Kalman filter algorithm benefits from substantial and significant decreases in computation time. However, it requires the additional assumption that the variance of the measurement equation / observations are independent. This assumption allows filtering to be performed through a sequential processing method (i.e. a univariate treatment of the multivariate process) - increasing computational efficiency. Sequential processing has been empirically shown to increase linearly, rather than exponentially, with increasing dimensionality of the observation matrix 'yt' (Aspinall et al., 2022, P104). Sequential processing is therefore a recommended method if there are many observations being filtered, there are NA's in the observation matrix, and the assumption of independence in observations can be adopted.</p>
<p>The 'fkf' function of the package 'FKF' (Fast Kalman Filter) is a function call of the traditional Kalman filter algorithm that is designed to maximize computational efficiency of the traditional filtering process. This vignette compares the computation times between these two Kalman filter algorithms.</p>
<p>This vignette provides five worked examples, comparing the computational efficiencies of the 'fkf' and 'fkf.SP' functions for maximum likelihood estimation (MLE). The first three examples were first presented within the associated vignette of the 'FKF' package, with the fourth being unique to the vignette. The fifth example provides a worked example of Kalman filtering and smoothing to a dataset. As well as the increase in processing time generated by the 'fkf.SP' function, this vignette further presents and explains the erroneous difference in log-likelihood values returned by the 'fkf' and 'fkf.SP' functions when there are missing observations (i.e. NA's are present within argument 'yt').</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">##The packages 'FKF', 'KFAS','stats' and 'NFCP' are required for this Vignette:
<span class="kw">library</span>(FKF.SP)
<span class="kw">library</span>(FKF)
<span class="kw">library</span>(stats)
<span class="kw">library</span>(NFCP)</code></pre></div>
</div>
<div id="example-1---arma21-model-estimation." class="section level2">
<h2>Example 1 - ARMA(2,1) model estimation.</h2>
<p>Autoregression moving average models can be estimated through Kalman filtering. See also help(makeARIMA) and help(KalmanRun).</p>
<p>Step 1 - Sample from an ARMA(2, 1) process through the 'stats' package to simulate observations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Set constants:</span>
## Length of series
n &lt;-<span class="st"> </span><span class="dv">10000</span>

## AR parameters
AR &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">ar1 =</span> <span class="fl">0.6</span>, <span class="dt">ar2 =</span> <span class="fl">0.2</span>, <span class="dt">ma1 =</span> <span class="op">-</span><span class="fl">0.2</span>, <span class="dt">sigma =</span> <span class="kw">sqrt</span>(<span class="fl">0.2</span>))

<span class="co"># Generate observations:</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
a &lt;-<span class="st"> </span>stats<span class="op">::</span><span class="kw">arima.sim</span>(<span class="dt">model =</span> <span class="kw">list</span>(<span class="dt">ar =</span> AR[<span class="kw">c</span>(<span class="st">&quot;ar1&quot;</span>, <span class="st">&quot;ar2&quot;</span>)], <span class="dt">ma =</span> AR[<span class="st">&quot;ma1&quot;</span>]), <span class="dt">n =</span> n,
            <span class="dt">innov =</span> <span class="kw">rnorm</span>(n) <span class="op">*</span><span class="st"> </span>AR[<span class="st">&quot;sigma&quot;</span>])</code></pre></div>
<p>Step 2 - Create a state space representation of the four ARMA parameters:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">arma21ss &lt;-<span class="st"> </span><span class="cf">function</span>(ar1, ar2, ma1, sigma) {
Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(ar1, ar2, <span class="dv">1</span>, <span class="dv">0</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)
Zt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">0</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)
ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)
dt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow =</span> <span class="dv">2</span>)
GGt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)
H &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, ma1), <span class="dt">nrow =</span> <span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>sigma
HHt &lt;-<span class="st"> </span>H <span class="op">%*%</span><span class="st"> </span><span class="kw">t</span>(H)
a0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)
## Diffuse assumption
P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="fl">1e6</span>, <span class="dt">nrow =</span> <span class="dv">2</span>, <span class="dt">ncol =</span> <span class="dv">2</span>)
<span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">ct =</span> ct, <span class="dt">dt =</span> dt, <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt, <span class="dt">GGt =</span> GGt,
            <span class="dt">HHt =</span> HHt))}</code></pre></div>
<p>Parameter estimation is performed through MLE, which involves optimizing the log-likelihood returned by the Kalman filter through the 'optim' function. Many other optimization procedures are available within R for more difficult optimization procedures (such as the package 'rgenoud'), such as when the log-likelihood is discontinuous, or multiple state variables are considered. Utilising both the Kalman filter and Kalman smoother to estimate parameters through expectation-maximization is another alternate approach.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
<span class="co"># The objective function passed to 'optim'</span>
objective &lt;-<span class="st"> </span><span class="cf">function</span>(theta, yt, SP) {
param &lt;-<span class="st"> </span><span class="kw">arma21ss</span>(theta[<span class="st">&quot;ar1&quot;</span>], theta[<span class="st">&quot;ar2&quot;</span>], theta[<span class="st">&quot;ma1&quot;</span>], theta[<span class="st">&quot;sigma&quot;</span>])
<span class="co"># Kalman filtering through the 'fkf.SP' function:</span>
<span class="cf">if</span>(SP){
 ans &lt;-<span class="st"> </span><span class="op">-</span><span class="st"> </span><span class="kw">fkf.SP</span>(<span class="dt">a0 =</span> param<span class="op">$</span>a0, <span class="dt">P0 =</span> param<span class="op">$</span>P0, <span class="dt">dt =</span> param<span class="op">$</span>dt, <span class="dt">ct =</span> param<span class="op">$</span>ct, 
               <span class="dt">Tt =</span> param<span class="op">$</span>Tt, <span class="dt">Zt =</span> param<span class="op">$</span>Zt, <span class="dt">HHt =</span> param<span class="op">$</span>HHt, <span class="dt">GGt =</span> param<span class="op">$</span>GGt, 
               <span class="dt">yt =</span> yt, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)<span class="op">$</span>logLik
 }
<span class="co"># Kalman filtering through the 'fkf' function:</span>
 <span class="cf">else</span>{
 ans &lt;-<span class="st"> </span><span class="op">-</span><span class="st"> </span><span class="kw">fkf</span>(<span class="dt">a0 =</span> param<span class="op">$</span>a0, <span class="dt">P0 =</span> param<span class="op">$</span>P0, <span class="dt">dt =</span> param<span class="op">$</span>dt, <span class="dt">ct =</span> param<span class="op">$</span>ct, <span class="dt">Tt =</span> param<span class="op">$</span>Tt,
            <span class="dt">Zt =</span> param<span class="op">$</span>Zt, <span class="dt">HHt =</span> param<span class="op">$</span>HHt, <span class="dt">GGt =</span> param<span class="op">$</span>GGt, <span class="dt">yt =</span> yt)<span class="op">$</span>logLik
   
 }
 <span class="kw">return</span>(ans)
}
##Optim minimizes functions by default, so the negative is returned</code></pre></div>
<p>Step 3 - Estimate parameters through MLE:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#This test estimates parameters through 'optim'.</span>
<span class="co">#Please run the complete chunk for a fair comparison:</span>

<span class="co">#Initial values:</span>
theta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">ar =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>), <span class="dt">ma1 =</span> <span class="dv">0</span>, <span class="dt">sigma =</span> <span class="dv">1</span>)

###MLE through the 'fkf' function:
start &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw">set.seed</span>(<span class="dv">1</span>)
FKF_estimation &lt;-<span class="st"> </span><span class="kw">optim</span>(theta, objective, <span class="dt">yt =</span> <span class="kw">rbind</span>(a), <span class="dt">hessian =</span> <span class="ot">TRUE</span>, <span class="dt">SP =</span> F)
FKF_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start

###MLE through the 'fkf.SP' function:
start &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw">set.seed</span>(<span class="dv">1</span>)
FKF.SP_estimation &lt;-<span class="st"> </span><span class="kw">optim</span>(theta, objective, <span class="dt">yt =</span> <span class="kw">rbind</span>(a), <span class="dt">hessian =</span> <span class="ot">TRUE</span>, <span class="dt">SP =</span> T)
FKF.SP_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</code></pre></div>
<p>The MLE process applying both functions has returned identical estimated parameters:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">rbind</span>(<span class="dt">FKF.SP =</span> FKF.SP_estimation<span class="op">$</span>par, <span class="dt">FKF =</span> FKF_estimation<span class="op">$</span>par))
<span class="co">#&gt;              ar1       ar2        ma1     sigma</span>
<span class="co">#&gt; FKF.SP 0.5534615 0.2276404 -0.1413417 0.4525427</span>
<span class="co">#&gt; FKF    0.5534615 0.2276404 -0.1413417 0.4525427</span></code></pre></div>
<p>As well as an identical call count number for both functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> FKF.SP_estimation<span class="op">$</span>counts[<span class="dv">1</span>], <span class="dt">FKF =</span> FKF_estimation<span class="op">$</span>counts[<span class="dv">1</span>]))
<span class="co">#&gt; FKF.SP.function    FKF.function </span>
<span class="co">#&gt;             265             265</span></code></pre></div>
<p>Utilizing Sequential Processing, however, we've decreased processing time:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> FKF.SP_runtime, <span class="dt">FKF =</span> FKF_runtime))
<span class="co">#&gt; Time differences in secs</span>
<span class="co">#&gt;   FKF.SP      FKF </span>
<span class="co">#&gt; 1.019001 1.403578</span></code></pre></div>
<p>Finally, under a variety of purposes, such as when parameters of the system have been estimated, it can be valuable to evaluate filtered state variables.</p>
<p>The filtered state variables and their filtered covariances are also identical between FKF and FKF.SP:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">FKF.SP_parameters &lt;-<span class="st"> </span><span class="kw">arma21ss</span>(FKF.SP_estimation<span class="op">$</span>par[<span class="dv">1</span>], FKF.SP_estimation<span class="op">$</span>par[<span class="dv">2</span>], FKF.SP_estimation<span class="op">$</span>par[<span class="dv">3</span>], FKF.SP_estimation<span class="op">$</span>par[<span class="dv">4</span>])
FKF_parameters &lt;-<span class="st"> </span><span class="kw">arma21ss</span>(FKF_estimation<span class="op">$</span>par[<span class="dv">1</span>], FKF_estimation<span class="op">$</span>par[<span class="dv">2</span>], FKF_estimation<span class="op">$</span>par[<span class="dv">3</span>], FKF_estimation<span class="op">$</span>par[<span class="dv">4</span>])

FKF_output &lt;-<span class="st"> </span>FKF<span class="op">::</span><span class="kw">fkf</span>(FKF_parameters<span class="op">$</span>a0, FKF_parameters<span class="op">$</span>P0, FKF_parameters<span class="op">$</span>dt, FKF_parameters<span class="op">$</span>ct, FKF_parameters<span class="op">$</span>Tt, FKF_parameters<span class="op">$</span>Zt, FKF_parameters<span class="op">$</span>HHt, FKF_parameters<span class="op">$</span>GGt, <span class="kw">rbind</span>(a))

FKF.SP_output &lt;-<span class="st"> </span>FKF.SP<span class="op">::</span><span class="kw">fkf.SP</span>(FKF_parameters<span class="op">$</span>a0, FKF_parameters<span class="op">$</span>P0, FKF_parameters<span class="op">$</span>dt, FKF_parameters<span class="op">$</span>ct, FKF_parameters<span class="op">$</span>Tt, FKF_parameters<span class="op">$</span>Zt, FKF_parameters<span class="op">$</span>HHt, FKF_parameters<span class="op">$</span>GGt, <span class="kw">rbind</span>(a), <span class="dt">verbose =</span> <span class="ot">TRUE</span>)

<span class="kw">print</span>(<span class="kw">head</span>(<span class="kw">t</span>(<span class="kw">rbind</span>(
<span class="co"># FKF</span>
FKF_output<span class="op">$</span>att[<span class="dv">1</span>,],
<span class="co"># FKF.SP</span>
FKF.SP_output<span class="op">$</span>att[<span class="dv">1</span>,]
))))
<span class="co">#&gt;             [,1]        [,2]</span>
<span class="co">#&gt; [1,] -0.10747402 -0.10747402</span>
<span class="co">#&gt; [2,]  0.03851773  0.03851773</span>
<span class="co">#&gt; [3,] -0.14022187 -0.14022187</span>
<span class="co">#&gt; [4,] -0.17502093 -0.17502093</span>
<span class="co">#&gt; [5,]  0.20129593  0.20129593</span>
<span class="co">#&gt; [6,]  0.27238242  0.27238242</span></code></pre></div>
<p>Under the condition that observations (i.e., the measurement error) are independent, a condition that occurs under many cases, it is therefore significantly beneficial to adopt sequential processing.</p>
</div>
<div id="example-2---local-level-model-for-the-niles-annual-flow" class="section level2">
<h2>Example 2 - Local level model for the Nile's annual flow:</h2>
<p>This example presents differences in the computational time of the 'fkf.SP' and 'fkf' functions to the famous Nile dataset.</p>
<p>It also shows the difference in log-likelihood values returned by the two functions that occurs when NAs are within observations.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Transition equation:
## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)

##Complete Nile Data - no NA's
y_complete &lt;-<span class="st"> </span>y_incomplete &lt;-<span class="st"> </span>Nile
##Incomplete Nile Data - two NA's are present:
y_incomplete[<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">10</span>)] &lt;-<span class="st"> </span><span class="ot">NA</span>


## Set constant parameters:
dt &lt;-<span class="st"> </span>ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)
Zt &lt;-<span class="st"> </span>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)
a0 &lt;-<span class="st"> </span>y_incomplete[<span class="dv">1</span>]   <span class="co"># Estimation of the first year flow</span>
P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">100</span>)     <span class="co"># Variance of 'a0'</span>
<span class="co"># 'P0' here is classified as a 'diffuse' initial state. A large estimate of the variance of the initial state variable is used when no prior information regarding state variance is known. This is again a common approach when performing Kalman filtering, and has been empirically shown to have little influence on estimated parameters, as future estimations are transient to the initial state. This is highly dependent, however, on the observations filtered, and caution should be advised.</span>

## Parameter estimation - maximum likelihood estimation:
Nile_MLE &lt;-<span class="st"> </span><span class="cf">function</span>(yt, SP){
##Unknown parameters initial estimates:
GGt &lt;-<span class="st"> </span>HHt &lt;-<span class="st"> </span><span class="kw">var</span>(yt, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span>.<span class="dv">5</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="co"># Kalman filtering through the 'fkf.SP' function:</span>
<span class="cf">if</span>(SP){
  <span class="kw">return</span>(<span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt),
        <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)
             <span class="op">-</span><span class="kw">fkf.SP</span>(<span class="dt">HHt =</span> <span class="kw">matrix</span>(par[<span class="dv">1</span>]), <span class="dt">GGt =</span> <span class="kw">matrix</span>(par[<span class="dv">2</span>]), ...)<span class="op">$</span>logLik,
             <span class="dt">yt =</span> <span class="kw">rbind</span>(yt), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,
             <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt, <span class="dt">verbose =</span> <span class="ot">TRUE</span>))
} <span class="cf">else</span> {
<span class="co"># Kalman filtering through the 'fkf' function:</span>
  <span class="kw">return</span>(<span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt),
        <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)
             <span class="op">-</span><span class="kw">fkf</span>(<span class="dt">HHt =</span> <span class="kw">matrix</span>(par[<span class="dv">1</span>]), <span class="dt">GGt =</span> <span class="kw">matrix</span>(par[<span class="dv">2</span>]), ...)<span class="op">$</span>logLik,
             <span class="dt">yt =</span> <span class="kw">rbind</span>(yt), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,
             <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt))
}}</code></pre></div>
<p>Performing parameter estimation using complete data, the fkf and fkf.SP functions return identical results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fkf.SP_MLE_complete &lt;-<span class="st"> </span><span class="kw">Nile_MLE</span>(y_complete, <span class="dt">SP =</span> T)
fkf_MLE_complete &lt;-<span class="st"> </span><span class="kw">Nile_MLE</span>(y_complete, <span class="dt">SP =</span> F)</code></pre></div>
<p>fkf.SP:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(fkf.SP_MLE_complete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
<span class="co">#&gt; $par</span>
<span class="co">#&gt;       HHt       GGt </span>
<span class="co">#&gt;  1300.777 15247.773 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $value</span>
<span class="co">#&gt; [1] 637.626</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $counts</span>
<span class="co">#&gt; function gradient </span>
<span class="co">#&gt;       57       NA</span></code></pre></div>
<p>fkf:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(fkf_MLE_complete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
<span class="co">#&gt; $par</span>
<span class="co">#&gt;       HHt       GGt </span>
<span class="co">#&gt;  1300.777 15247.773 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $value</span>
<span class="co">#&gt; [1] 637.626</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $counts</span>
<span class="co">#&gt; function gradient </span>
<span class="co">#&gt;       57       NA</span></code></pre></div>
<p>Performing parameter estimation using incomplete data returns identical estimated parameters, but different log-likelihood values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fkf.SP_MLE_incomplete &lt;-<span class="st"> </span><span class="kw">Nile_MLE</span>(y_incomplete, <span class="dt">SP =</span> T)
fkf_MLE_incomplete &lt;-<span class="st"> </span><span class="kw">Nile_MLE</span>(y_incomplete, <span class="dt">SP =</span> F)</code></pre></div>
<p>'fkf.SP':</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(fkf.SP_MLE_incomplete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
<span class="co">#&gt; $par</span>
<span class="co">#&gt;       HHt       GGt </span>
<span class="co">#&gt;  1385.066 15124.131 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $value</span>
<span class="co">#&gt; [1] 625.1676</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $counts</span>
<span class="co">#&gt; function gradient </span>
<span class="co">#&gt;       53       NA</span></code></pre></div>
<p>'fkf':</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(fkf_MLE_incomplete[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>])
<span class="co">#&gt; $par</span>
<span class="co">#&gt;       HHt       GGt </span>
<span class="co">#&gt;  1385.066 15124.131 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $value</span>
<span class="co">#&gt; [1] 627.0055</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $counts</span>
<span class="co">#&gt; function gradient </span>
<span class="co">#&gt;       53       NA</span></code></pre></div>
<p>The difference in log-likelihood values is equal to 1.8378771. This difference is equal to:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Number of NA values:</span>
NA_values &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">which</span>(<span class="kw">is.na</span>(y_incomplete)))

<span class="kw">print</span>( <span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>NA_values <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(<span class="dv">2</span> <span class="op">*</span><span class="st"> </span>pi))
<span class="co">#&gt; [1] 1.837877</span></code></pre></div>
<p>The log-likelihood score for the Kalman filter is given by:</p>
<p><span class="math display">\[ - \frac{1}{2}(n \times d \times log(2\pi)) - \frac{1}{2}\sum_{t=1}^{n}(log|F_t| + v'F^{-1}v)\]</span> where <span class="math inline">\(n\)</span> is the number of discrete time-steps (i.e. the number of columns of object 'yt') and <span class="math inline">\(d\)</span> is the number of observations at each time point (i.e. the number of rows of object 'yt'). <span class="math inline">\(v\)</span> and <span class="math inline">\(F_t\)</span> are the measurement error and function of the covariance matrix at time <span class="math inline">\(t\)</span> respectively. The 'fkf' function instantiates its log-likelihood score by calculating <span class="math inline">\(- 0.5 \times n \times d \times log(2\pi)\)</span>. Under the scenario where there are missing observations, however, <span class="math inline">\(d\)</span> would instead become <span class="math inline">\(d_t\)</span> where <span class="math inline">\(d_t \leq d \forall t\)</span>. The instantiated log-likelihood term would instead be <span class="math inline">\(- 0.5 ((n \times d)-2) \times log(2\pi)\)</span>, explaining this difference in log-likelihood scores. The 'fkf' function, in this case, therefore instantiates the log-likelihood score of two observations that are not actually observed.</p>
<div id="speed-comparison---nile-data-10000-iterations" class="section level3">
<h3>Speed Comparison - Nile Data (10,000 iterations):</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#This test uses estimated parameters of complete data. </span>
<span class="co">#Please run the complete chunk for a fair comparison:</span>

<span class="co">#'fkf' </span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
start &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e4</span>) <span class="kw">fkf</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">matrix</span>(fkf_MLE_complete<span class="op">$</span>par[<span class="dv">1</span>]),
                    <span class="dt">GGt =</span> <span class="kw">matrix</span>(fkf_MLE_complete<span class="op">$</span>par[<span class="dv">2</span>]), <span class="dt">yt =</span> <span class="kw">rbind</span>(y_complete))
FKF_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start

<span class="co">#'fkf.SP'</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
start =<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e4</span>) <span class="kw">fkf.SP</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">matrix</span>(fkf.SP_MLE_complete<span class="op">$</span>par[<span class="dv">1</span>]),
                       <span class="dt">GGt =</span> <span class="kw">matrix</span>(fkf.SP_MLE_complete<span class="op">$</span>par[<span class="dv">2</span>]), <span class="dt">yt =</span> <span class="kw">rbind</span>(y_complete), <span class="dt">verbose =</span> <span class="ot">TRUE</span>)
fkf.SP_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start

<span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> fkf.SP_runtime, <span class="dt">FKF =</span> FKF_runtime))
<span class="co">#&gt; Time differences in secs</span>
<span class="co">#&gt;    FKF.SP       FKF </span>
<span class="co">#&gt; 0.5973079 0.8233068</span></code></pre></div>
<p>Utilizing Sequential Processing has decreased processing time.</p>
</div>
</div>
<div id="example-3---tree-ring-data" class="section level2">
<h2>Example 3 - Tree Ring Data:</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#This test estimates parameters 10 times through 'optim'.</span>
<span class="co">#Please run the complete chunk for a fair comparison:</span>

## Transition equation:
## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)

## tree-ring widths in dimensionless units
y &lt;-<span class="st"> </span>treering

## Set constant parameters:
dt &lt;-<span class="st"> </span>ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)
Zt &lt;-<span class="st"> </span>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)
a0 &lt;-<span class="st"> </span>y[<span class="dv">1</span>]            <span class="co"># Estimation of the first width</span>
P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">100</span>)     <span class="co"># Variance of 'a0'</span>

##Time comparison - Estimate parameters 10 times:

###MLE through the 'fkf' function:
start =<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)  fit_fkf &lt;-<span class="st"> </span><span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span>.<span class="dv">5</span>,
                     <span class="dt">GGt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span>.<span class="dv">5</span>),
                   <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)
                     <span class="op">-</span><span class="kw">fkf</span>(<span class="dt">HHt =</span> <span class="kw">array</span>(par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), <span class="dt">GGt =</span> <span class="kw">array</span>(par[<span class="dv">2</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), ...)<span class="op">$</span>logLik,
                   <span class="dt">yt =</span> <span class="kw">rbind</span>(y), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,
                   <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt)

run_time_FKF =<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start

###MLE through the 'fkf.SP' function:
start =<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)  fit_fkf.SP &lt;-<span class="st"> </span><span class="kw">optim</span>(<span class="kw">c</span>(<span class="dt">HHt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span>.<span class="dv">5</span>,
                        <span class="dt">GGt =</span> <span class="kw">var</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span>.<span class="dv">5</span>),
                      <span class="dt">fn =</span> <span class="cf">function</span>(par, ...)
                        <span class="op">-</span><span class="kw">fkf.SP</span>(<span class="dt">HHt =</span> <span class="kw">array</span>(par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), <span class="dt">GGt =</span> <span class="kw">matrix</span>(par[<span class="dv">2</span>]),<span class="dt">verbose =</span> <span class="ot">TRUE</span>, ...)<span class="op">$</span>logLik,
                      <span class="dt">yt =</span> <span class="kw">rbind</span>(y), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,
                      <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt)
run_time_FKF.SP =<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start

<span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">fkf.SP =</span> run_time_FKF.SP, <span class="dt">fkf =</span> run_time_FKF))
<span class="co">#&gt; Time differences in secs</span>
<span class="co">#&gt;   fkf.SP      fkf </span>
<span class="co">#&gt; 1.560650 1.910009</span></code></pre></div>
<p>Utilizing Sequential Processing has decreased processing time.</p>
<p>Additionally - Identical filtered values are returned:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
## Filter tree ring data with estimated parameters using 'fkf':
fkf.obj &lt;-<span class="st"> </span><span class="kw">fkf</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">array</span>(fit_fkf<span class="op">$</span>par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)),
               <span class="dt">GGt =</span> <span class="kw">array</span>(fit_fkf<span class="op">$</span>par[<span class="dv">2</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)), <span class="dt">yt =</span> <span class="kw">rbind</span>(y))
## Filter tree ring data with estimated parameters using 'fkf.SP':
fkf.SP.obj &lt;-<span class="st"> </span><span class="kw">fkf.SP</span>(a0, P0, dt, ct, Tt, Zt, <span class="dt">HHt =</span> <span class="kw">array</span>(fit_fkf<span class="op">$</span>par[<span class="dv">1</span>],<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)),
               <span class="dt">GGt =</span> <span class="kw">matrix</span>(fit_fkf<span class="op">$</span>par[<span class="dv">2</span>]), <span class="dt">yt =</span> <span class="kw">rbind</span>(y), <span class="dt">verbose =</span> <span class="ot">TRUE</span>)

<span class="kw">print</span>(<span class="kw">head</span>(<span class="kw">cbind</span>(<span class="dt">FKF =</span> fkf.obj<span class="op">$</span>Ptt[<span class="dv">1</span>,,], <span class="dt">FKF.SP =</span> fkf.SP.obj<span class="op">$</span>Ptt[<span class="dv">1</span>,,])))
<span class="co">#&gt;             FKF     FKF.SP</span>
<span class="co">#&gt; [1,] 0.08216834 0.08216834</span>
<span class="co">#&gt; [2,] 0.04122259 0.04122259</span>
<span class="co">#&gt; [3,] 0.02767374 0.02767374</span>
<span class="co">#&gt; [4,] 0.02097740 0.02097740</span>
<span class="co">#&gt; [5,] 0.01702170 0.01702170</span>
<span class="co">#&gt; [6,] 0.01443543 0.01443543</span></code></pre></div>
</div>
<div id="example-4---fitting-a-geometric-brownian-motion-gbm-to-term-structure-data" class="section level2">
<h2>Example 4 - Fitting a Geometric Brownian Motion (GBM) to Term Structure Data:</h2>
<p>The Kalman filter can be used to fit stochastic models to time-series data of quoted prices of futures contracts of commodities. The following example estimates the parameters of a random walk (i.e. geometric Brownian motion) model for crude oil through MLE. Quoted futures contracts are available in the 'NFCP' package. See the 'NFCP' documentation for more details on fitting commodity pricing models to term structure data.</p>
<p>Step 1 - develop the objective function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
yt =<span class="st"> </span><span class="kw">t</span>(<span class="kw">log</span>(NFCP<span class="op">::</span>SS_oil<span class="op">$</span>contracts)) <span class="co"># quoted log futures prices</span>
delta_t &lt;-<span class="st"> </span>NFCP<span class="op">::</span>SS_oil<span class="op">$</span>dt <span class="co"># Discrete time step</span>
##time to maturity of quoted futures contracts:
TTM &lt;-<span class="st"> </span><span class="kw">t</span>(NFCP<span class="op">::</span>SS_oil<span class="op">$</span>contract_maturities)

a0 &lt;-<span class="st"> </span>yt[<span class="dv">1</span>,<span class="dv">1</span>]     <span class="co"># initial estimate</span>
P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">100</span>) <span class="co"># Variance of 'a0'</span>

## GBM Function
gbm_mle &lt;-<span class="st"> </span><span class="cf">function</span>(theta, SP){

ct &lt;-<span class="st"> </span>theta[<span class="st">&quot;alpha_rn&quot;</span>] <span class="op">*</span><span class="st"> </span>TTM
dt &lt;-<span class="st"> </span>(theta[<span class="st">&quot;alpha&quot;</span>] <span class="op">-</span><span class="st"> </span><span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>theta[<span class="st">&quot;sigma&quot;</span>]<span class="op">^</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>delta_t
Zt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(yt))
HHt &lt;-<span class="st"> </span><span class="kw">matrix</span>(theta[<span class="st">&quot;sigma&quot;</span>]<span class="op">^</span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta_t)
Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)

##'fkf.SP' requires a vector of the diagonal elements of the variances of the measurement error 
<span class="cf">if</span>(SP){
GGt =<span class="st"> </span><span class="kw">rep</span>(theta[<span class="st">&quot;ME_1&quot;</span>]<span class="op">^</span><span class="dv">2</span>, <span class="kw">nrow</span>(yt))
} <span class="cf">else</span> {
##'fkf' instead requires a matrix of the elements of the variances of the measurement error 
GGt =<span class="st"> </span><span class="kw">diag</span>(theta[<span class="st">&quot;ME_1&quot;</span>]<span class="op">^</span><span class="dv">2</span>, <span class="kw">nrow</span>(yt))
}

##'fkf.SP' returns only the log-likelihood numeric value when Verbose = FALSE, whilst 'fkf' returns a list of filtered values
logLik =<span class="st"> </span><span class="kw">ifelse</span>(SP,
                <span class="op">-</span><span class="st"> </span><span class="kw">fkf.SP</span>(<span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct, <span class="dt">Tt =</span> Tt, <span class="dt">Zt =</span> Zt, <span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt, <span class="dt">yt =</span> yt, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)<span class="op">$</span>logLik,
                <span class="op">-</span><span class="st"> </span><span class="kw">fkf</span>(<span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct, <span class="dt">Tt =</span> Tt, <span class="dt">Zt =</span> Zt, <span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt, <span class="dt">yt =</span> yt)<span class="op">$</span>logLik
                )
<span class="kw">return</span>(logLik)
}</code></pre></div>
<p>Step 2 - Perform MLE:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#This test estimates parameters through 'optim'.</span>
<span class="co">#Please run the complete chunk for a fair comparison:</span>

<span class="co">#Initial estimates</span>
gbm_par &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">alpha =</span> <span class="dv">0</span>, <span class="dt">alpha_rn =</span> <span class="fl">0.01</span>, <span class="dt">sigma =</span> <span class="fl">0.1</span>, <span class="dt">ME_1 =</span> <span class="fl">0.05</span>)

###MLE through the 'fkf.SP' function:
<span class="kw">set.seed</span>(<span class="dv">1</span>)
start =<span class="st"> </span><span class="kw">Sys.time</span>()
fkf.SP.gbm =<span class="st"> </span><span class="kw">optim</span>(<span class="dt">par =</span> gbm_par, <span class="dt">fn =</span> gbm_mle, <span class="dt">SP =</span> T)
fkf.SP_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start

###MLE through the 'fkf' function:
<span class="kw">set.seed</span>(<span class="dv">1</span>)
start =<span class="st"> </span><span class="kw">Sys.time</span>()
fkf.gbm =<span class="st"> </span><span class="kw">optim</span>(<span class="dt">par =</span> gbm_par, <span class="dt">fn =</span> gbm_mle, <span class="dt">SP =</span> F)
fkf_runtime &lt;-<span class="st"> </span><span class="kw">Sys.time</span>() <span class="op">-</span><span class="st"> </span>start</code></pre></div>
<p>The presence of a large number of NA's in the observation matrix (i.e. object 'yt') has resulted in significantly different MLE scores of both functions (see Example 3 for more details):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">rbind</span>(<span class="dt">FKF.SP =</span> <span class="op">-</span><span class="st"> </span>fkf.SP.gbm<span class="op">$</span>value, <span class="dt">FKF =</span> <span class="op">-</span><span class="st"> </span>fkf.gbm<span class="op">$</span>value))
<span class="co">#&gt;             [,1]</span>
<span class="co">#&gt; FKF.SP 10221.345</span>
<span class="co">#&gt; FKF    -4778.489</span></code></pre></div>
<p>Regardless, The MLE process applying both functions has returned nearly identical estimated parameters:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">rbind</span>(<span class="dt">FKF.SP =</span> fkf.SP.gbm<span class="op">$</span>par, <span class="dt">FKF =</span> fkf.gbm<span class="op">$</span>par))
<span class="co">#&gt;              alpha    alpha_rn     sigma       ME_1</span>
<span class="co">#&gt; FKF.SP -0.02283278 0.001236720 0.2070780 0.03721549</span>
<span class="co">#&gt; FKF    -0.02277886 0.001234892 0.2071917 0.03721757</span></code></pre></div>
<p>As well as a nearly identical call count number for both functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> fkf.SP.gbm<span class="op">$</span>counts[<span class="dv">1</span>], <span class="dt">FKF =</span> fkf.gbm<span class="op">$</span>counts[<span class="dv">1</span>]))
<span class="co">#&gt; FKF.SP.function    FKF.function </span>
<span class="co">#&gt;             145             153</span></code></pre></div>
<p>A sequential processing approach, however, has significantly decreased processing time:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">c</span>(<span class="dt">FKF.SP =</span> fkf.SP_runtime, <span class="dt">FKF =</span> fkf_runtime))
<span class="co">#&gt; Time differences in secs</span>
<span class="co">#&gt;    FKF.SP       FKF </span>
<span class="co">#&gt; 0.2015769 3.7294381</span></code></pre></div>
<p>Sequential processing is a significantly faster Kalman filtering approach for this particular example due to the large number of observations at each time point, the assumption that the variance of the disturbances are independent, the large number of NA's that are observed as contracts expired or are made available and the dimensionality of argument 'GGt' being significantly reduced.</p>
<p>Finally, the filtered values, which in this case correspond to the estimated log of the spot price, are identical through both functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ct &lt;-<span class="st"> </span>fkf.SP.gbm<span class="op">$</span>par[<span class="st">'alpha_rn'</span>] <span class="op">*</span><span class="st"> </span>TTM
dt &lt;-<span class="st"> </span>(fkf.SP.gbm<span class="op">$</span>par[<span class="st">'alpha'</span>] <span class="op">-</span><span class="st"> </span><span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>fkf.SP.gbm<span class="op">$</span>par[<span class="st">'sigma'</span>]<span class="op">^</span><span class="dv">2</span>) <span class="op">*</span><span class="st"> </span>delta_t
Zt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>, <span class="kw">nrow</span>(yt))
HHt &lt;-<span class="st"> </span><span class="kw">matrix</span>(fkf.SP.gbm<span class="op">$</span>par[<span class="st">'sigma'</span>]<span class="op">^</span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>delta_t)
Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)

GGt.SP &lt;-<span class="st"> </span><span class="kw">rep</span>(fkf.SP.gbm<span class="op">$</span>par[<span class="st">'ME_1'</span>]<span class="op">^</span><span class="dv">2</span>, <span class="kw">nrow</span>(yt))
GGt &lt;-<span class="st"> </span><span class="kw">diag</span>(fkf.SP.gbm<span class="op">$</span>par[<span class="st">'ME_1'</span>]<span class="op">^</span><span class="dv">2</span>, <span class="kw">nrow</span>(yt))

GBM_fkf &lt;-<span class="st"> </span><span class="kw">fkf</span>(<span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct, <span class="dt">Tt =</span> Tt, <span class="dt">Zt =</span> Zt, <span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt, <span class="dt">yt =</span> yt)
GBM_fkf.SP &lt;-<span class="st"> </span><span class="kw">fkf.SP</span>(<span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct, <span class="dt">Tt =</span> Tt, <span class="dt">Zt =</span> Zt, <span class="dt">HHt =</span> HHt, <span class="dt">GGt =</span> GGt.SP, <span class="dt">yt =</span> yt, <span class="dt">verbose =</span> <span class="ot">TRUE</span>)

Filtered_values &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">rbind</span>(<span class="dt">FKF =</span> GBM_fkf<span class="op">$</span>att, <span class="dt">FKF.SP =</span> GBM_fkf.SP<span class="op">$</span>att))
<span class="kw">colnames</span>(Filtered_values) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;FKF&quot;</span>, <span class="st">&quot;FKF.SP&quot;</span>)

<span class="kw">print</span>(<span class="kw">head</span>(Filtered_values))
<span class="co">#&gt;           FKF   FKF.SP</span>
<span class="co">#&gt; [1,] 3.032519 3.032519</span>
<span class="co">#&gt; [2,] 2.979634 2.979634</span>
<span class="co">#&gt; [3,] 2.970764 2.970764</span>
<span class="co">#&gt; [4,] 2.966605 2.966605</span>
<span class="co">#&gt; [5,] 3.003469 3.003469</span>
<span class="co">#&gt; [6,] 3.007449 3.007449</span></code></pre></div>
</div>
<div id="example-5---kalman-smoothing" class="section level2">
<h2>Example 5 - Kalman smoothing:</h2>
<p>Kalman smoothing is an algorithm that allows one to refine estimates of previous states, conditional on the filtered observations. This is useful when performing expectation maximization (EM) approaches to parameter estimation. The 'FKF.SP' package allows for Kalman smoothing in two ways. The first way is to simply set the argument &quot;smoothing = TRUE&quot; when performing Kalman filtering through the 'fkf.SP' function. Alternatively, if a state space model has been filtered with the argument 'verbose = TRUE', then the 'fks.SP' function may be used on the returned object. The solution to Kalman smoothing through sequential processing is available in the documentation of the 'fks.SP' function.</p>
<p>The 'fks.SP' function takes an object of class 'fkf.SP', which is returned whenever the 'fkf.SP' function is called with the argument 'verbose = TRUE'.</p>
<p>This worked example compares the relative speeds of filtering, and then smoothing, the Nile data, between the 'FKF' and 'FKF.SP' packages.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#This test compares processing speeds of function calls using a set number of iterations.</span>
<span class="co">#Please run the complete chunk for a fair comparison:</span>

## Transition equation:
## alpha[t+1] = alpha[t] + eta[t], eta[t] ~ N(0, HHt)
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)

##Nile Data:
yt &lt;-<span class="st"> </span>Nile

## Set constant parameters:
dt &lt;-<span class="st"> </span>ct &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>)
Zt &lt;-<span class="st"> </span>Tt &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>)
a0 &lt;-<span class="st"> </span>yt[<span class="dv">1</span>]             <span class="co"># Estimation of the first year flow</span>
P0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">100</span>)       <span class="co"># Variance of 'a0'</span>


<span class="co"># Parameter estimation - maximum likelihood estimation:</span>
<span class="co"># Unknown parameters initial estimates:</span>
GGt &lt;-<span class="st"> </span>HHt &lt;-<span class="st"> </span><span class="kw">var</span>(yt, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">*</span><span class="st"> </span>.<span class="dv">5</span>
HHt =<span class="st"> </span><span class="kw">matrix</span>(HHt)
GGt =<span class="st"> </span><span class="kw">matrix</span>(GGt)
yt =<span class="st"> </span><span class="kw">rbind</span>(yt)

<span class="co"># Run each function call 10,000 times to minimize variance:</span>
N_iterations &lt;-<span class="st"> </span><span class="fl">1e4</span>

## # Kalman filtering, and then smoothing, through each approach:

<span class="co"># FKF:</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
FKF_start_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N_iterations){
  <span class="co"># Filtering:</span>
  FKF_Nile_filtered &lt;-<span class="st"> </span><span class="kw">fkf</span>(<span class="dt">HHt =</span> <span class="kw">matrix</span>(HHt), <span class="dt">GGt =</span> <span class="kw">matrix</span>(GGt), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,
                 <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt, <span class="dt">yt =</span> <span class="kw">rbind</span>(yt))
  <span class="co"># Smoothing:</span>
  FKF_Nile_smoothed &lt;-<span class="st"> </span><span class="kw">fks</span>(FKF_Nile_filtered)
}
FKF_runtime &lt;-<span class="st"> </span><span class="kw">difftime</span>(<span class="kw">Sys.time</span>(), FKF_start_time, <span class="dt">units =</span> <span class="st">&quot;secs&quot;</span>)


<span class="co"># FKF.SP - Approach 1:</span>
<span class="co"># Filtering, and then smoothing, using 'smoothing = TRUE':</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
FKF.SP_1_start_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N_iterations){
  FKF.SP_1_Nile_filtered_smoothed &lt;-<span class="st"> </span><span class="kw">fkf.SP</span>(<span class="dt">HHt =</span> <span class="kw">matrix</span>(HHt), <span class="dt">GGt =</span> <span class="kw">matrix</span>(GGt), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,
                 <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt, <span class="dt">yt =</span> <span class="kw">rbind</span>(yt), <span class="dt">smoothing =</span> <span class="ot">TRUE</span>)
}
FKF.SP_1_runtime &lt;-<span class="st"> </span><span class="kw">difftime</span>(<span class="kw">Sys.time</span>(), FKF.SP_1_start_time, <span class="dt">units =</span> <span class="st">&quot;secs&quot;</span>)

<span class="co"># FKF.SP - Approach 2:</span>
<span class="co"># Filtering a model using 'verbose = TRUE', and then smoothing using the returned object:</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
FKF.SP_2_start_time &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N_iterations){
  <span class="co"># Filtering:</span>
  FKF.SP_Nile_filtered &lt;-<span class="st"> </span><span class="kw">fkf.SP</span>(<span class="dt">HHt =</span> <span class="kw">matrix</span>(HHt), <span class="dt">GGt =</span> <span class="kw">matrix</span>(GGt), <span class="dt">a0 =</span> a0, <span class="dt">P0 =</span> P0, <span class="dt">dt =</span> dt, <span class="dt">ct =</span> ct,
                 <span class="dt">Zt =</span> Zt, <span class="dt">Tt =</span> Tt, <span class="dt">yt =</span> <span class="kw">rbind</span>(yt), <span class="dt">verbose =</span> <span class="ot">TRUE</span>)
  <span class="co"># Smoothing:</span>
  FKF.SP_2_Nile_smoothed &lt;-<span class="st"> </span><span class="kw">fks.SP</span>(FKF.SP_Nile_filtered)
}
FKF.SP_2_runtime &lt;-<span class="st"> </span><span class="kw">difftime</span>(<span class="kw">Sys.time</span>(), FKF.SP_2_start_time, <span class="dt">units =</span> <span class="st">&quot;secs&quot;</span>)

<span class="kw">print</span>(<span class="kw">c</span>(<span class="st">&quot;FKF.SP (Approach 1)&quot;</span> =<span class="st"> </span>FKF.SP_1_runtime, <span class="st">&quot;FKF.SP (Approach 2)&quot;</span> =<span class="st"> </span>FKF.SP_2_runtime, <span class="st">&quot;FKF&quot;</span>=<span class="st"> </span>FKF_runtime))
<span class="co">#&gt; Time differences in secs</span>
<span class="co">#&gt; FKF.SP (Approach 1) FKF.SP (Approach 2)                 FKF </span>
<span class="co">#&gt;           0.9048891           0.8839259           1.2231350</span></code></pre></div>
<p>Utilizing Sequential Processing has decreased processing time when both filtering and smoothing. Approach 1 of Kalman filtering, and then smoothing, through the FKF.SP package results in both the Kalman filter and Kalman smoother recursions being run in the same compiled C function call.</p>
<p>Finally, the smoothed values returned by the three functions are identical:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">
Smoothed_values &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">rbind</span>(FKF.SP_1_Nile_filtered_smoothed<span class="op">$</span>ahatt, FKF.SP_2_Nile_smoothed<span class="op">$</span>ahatt, FKF_Nile_smoothed<span class="op">$</span>ahatt))
<span class="kw">colnames</span>(Smoothed_values) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;FKF.SP (Approach 1)&quot;</span>,<span class="st">&quot;FKF.SP (Approach 2)&quot;</span>, <span class="st">&quot;FKF&quot;</span>)

<span class="kw">print</span>(<span class="kw">head</span>(Smoothed_values))
<span class="co">#&gt;      FKF.SP (Approach 1) FKF.SP (Approach 2)      FKF</span>
<span class="co">#&gt; [1,]            1119.985            1119.985 1119.985</span>
<span class="co">#&gt; [2,]            1117.839            1117.839 1117.839</span>
<span class="co">#&gt; [3,]            1073.533            1073.533 1073.533</span>
<span class="co">#&gt; [4,]            1139.758            1139.758 1139.758</span>
<span class="co">#&gt; [5,]            1135.743            1135.743 1135.743</span>
<span class="co">#&gt; [6,]            1107.470            1107.470 1107.470</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
